Connor Williams ID: 161-40313
CS270 Dr. Wilder
4/4/2018

System calls used by ddup:
	1.	opendir()
	2.	closedir()
	3.	readdir()
	4.	open()
	5.	read()
	6.	write()
	7.	stat()
	
Objectives that assignment does not meet:
	I have tested this program with many different scenarios, and it meets all assignment objectives. There is only one bug that I found with it,
	which is if the source directory either is or includes the destination directory as a subdirectory, the program recurses into that directory,
	 copying its contents and placing them in the destination repeatedly. I'm not sure how to stop this from happening.

Summary:

	I think the most important lesson that I learned in this assignment was the usefulness of system calls. \nIn previous assignments, we were only
	able to make modifications to the computer through library functions, which can be quite a pain to learn how to use, and they are not near as fun
	to use as compared to system calls. I faced quite a few problems during this assignment and came to really hate the words “Segmentation Fault”. 
	The issue that took me the longest amount of time to resolve was the fact that c strings are always passed “by reference” into functions, whereas
	C++ style strings are not. This was a problem when trying to pass a file path recursively, as I needed the path to only be incremented to be one file
	step ahead and then revert to what it was when the recursive function returned to a previous call of it. Passing by value meant it was not doing this,
	and I had files and segmentation faults all over the place. After some web searching, I found a nifty function named “snprintf()”, which came in very 
	useful in solving this problem. Another problem I had that affected ddup’s behavior was, when writing to a file, I was not keeping track of how many 
	bytes were read. This meant the write function was writing 1024 bytes, stored in the buffer, every time it was being called, which placed lots of 
	“garbage” characters into the copied file’s destination. The last important issue that I had was using a c string as a buffer for the read function when 
	trying to compare a file’s contents. For whatever reason, the read() function was filling the buffer with random garbage, which resulted in inaccurate
	comparisons, and copying a file when it was not supposed to. I fixed this by using a character array of size 100,000. While 100,000 bytes is not that 
	large, I figured for these purposes, if a file is the same size and has the same content for 100k bytes, it is probably the same file.